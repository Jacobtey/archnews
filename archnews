#!/usr/bin/env python3

"""
Utility for displaying Arch news feed in console.

author: Martin Jiřička (mjiricka@gmail.com), 2017

licence: MIT
"""

import argparse
import locale
import re
import sys
from datetime import datetime, timedelta, timezone
from email.utils import parsedate_tz, mktime_tz
from html.parser import HTMLParser
from os import makedirs, path
from os.path import expanduser
from re import sub
from textwrap import wrap
from urllib import request
from xml.dom import minidom


# ************************************************************
#  Globals
# ************************************************************

FEED_URL = 'https://www.archlinux.org/feeds/news/'
DATA_FILE_REL_PATH = '~/.config/archnews'
DATA_FILE_PATH = expanduser(DATA_FILE_REL_PATH)

DATA_FILE_FORMAT = '%Y-%m-%d %H:%M:%S %z'

WRAP_SIZE = 100  # Zero for no wrap.
COLORIZE_OUTPUT = True
ORDER = True  # True = newest entries last, False = newest entries first
NUM_ENTRIES = 3  # 0 for all


# ************************************************************
#  Output
# ************************************************************

class Out:
    """Class for printing output, it supports color printing. Printing method must be
       initialized via `set` method that adds `print` method."""
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    GRAY = '\033[90m'
    ENDC = '\033[0m'

    @staticmethod
    def _color_print(color, text):
        """Prints colored text, possible colors: green, blue and red."""
        if color == 'green':
            print(Out.GREEN + text + Out.ENDC)
        elif color == 'blue':
            print(Out.BLUE + text + Out.ENDC)
        elif color == 'gray':
            print(Out.GRAY + text + Out.ENDC)

    @staticmethod
    def _white_print(_, text):
        """Prints text."""
        print(text)

    @staticmethod
    def set(colorize_output):
        """Sets the default value."""
        if colorize_output:
            Out.print = Out._color_print
        else:
            Out.print = Out._white_print


# ************************************************************
#  HTML parser
# ************************************************************

class TheParser(HTMLParser):
    """Parser formats HTML into plain text, result is stored inside `out` property."""
    def __init__(self):
        super(TheParser, self).__init__()

        self.out = ''
        self._stack = []
        self._inside_pre = False

    @staticmethod
    def _squeeze_whitespace(text):
        """Squeezes whitespaces into one single space."""
        return sub(r'\s+', ' ', text)

    def _append(self, text):
        if not text:
            return

        if self.out:
            last_char = self.out[-1]
        else:
            last_char = ''

        if last_char.isspace():
            if text[0] in [' ', '\t']:
                # Squeeze spaces, unless they are intended (intended are those in
                # `text` variable).
                self.out = self.out.rstrip(' \t') + text
            else:
                if last_char == text[0] == '\n':
                    # This ensures that at most two consecutive new lines are added.
                    self.out = self.out.rstrip() + '\n\n' + text.lstrip('\n')
                else:
                    self.out += text
        else:
            self.out += text

    def _append_raw(self, text):
        self.out += text

    def handle_starttag(self, tag, attrs):
        self._stack.append(tag)

        if tag == 'a':
            self._append('<')
        elif tag == 'br':
            self._append('\n')
        elif tag == 'pre':
            self._inside_pre = True
        elif tag == 'li':
            self._append(' \u2022 ')  # Bullet Unicode symbol.

    def handle_endtag(self, tag):
        # HTML might be invalid, so check the emptiness.
        if self._stack:
            self._stack.pop()

        if tag in ['p', 'div']:
            self._append('\n\n')
        elif tag == 'a':
            self._append('>')
        elif tag in ['li', 'ul', 'ol']:
            self._append('\n')
        elif tag == 'pre':
            self._inside_pre = False
            self._append('\n')

    def handle_data(self, data):
        if self._stack:
            tag = self._stack[-1]
        else:
            tag = ''

        if self._inside_pre:
            # Everything inside <pre> is indented by three spaces.
            indented_data = '\n'.join(['   '+line for line in data.split('\n')])
            self._append_raw(indented_data)
        elif tag == 'code':
            self._append(data.replace(' ', '\u00A0'))  # Non breaking space.
        elif tag == 'pre':
            self._append('\n')
        else:
            squeezed_data = self._squeeze_whitespace(data)
            # Do not allow spaces at a paragraph beginning.
            if squeezed_data != ' ' or (self.out and self.out[-1] != '\n'):
                self._append(squeezed_data)

    def error(self, message):
        raise SyntaxError('Error when parsing message: ' + message)

    @staticmethod
    def unhtml(text):
        """Uses parser on given `text` and returns the result."""
        parser = TheParser()
        parser.feed(text)
        return parser.out


# ************************************************************
#  Wrap
# ************************************************************

class Wrap:
    """Class for wrapping text on given width. It must be configured the same
       way as class `Out`: `set` method and then `wrap` method."""

    _wrap_size = 0

    @staticmethod
    def _make_wrap(text):
        """Function wrap text."""
        def wrap_line(line):
            """Function wraps one line of unintended (3 spaces) code."""
            if line[0:3] == '   ':
                return line
            return '\n'.join(
                wrap(line, Wrap._wrap_size, drop_whitespace=True, break_long_words=False))

        lines = text.split('\n')
        lines2 = [wrap_line(l) for l in lines]
        text_wrapped = '\n'.join(lines2)
        return text_wrapped

    @staticmethod
    def _no_wrap(text):
        """Function does not wrap anything."""
        return text

    @staticmethod
    def set(wrap_size):
        """Sets the default value."""
        Wrap._wrap_size = wrap_size
        if wrap_size == 0:
            Wrap.wrap = Wrap._no_wrap
        else:
            Wrap.wrap = Wrap._make_wrap


# ************************************************************
#  Feed-related classes.
# ************************************************************

REMOVE_TAGS_REGEXP = re.compile(r'<.*?>')

class FeedEntry:
    """Represents single news feed entry."""
    def __init__(self, time, title, link, description):
        self.time = time
        self.title = title
        self.link = link
        self.description = description

    def print(self, wrap_func):
        """Prints news feed entry."""
        Out.print('gray', self.link)
        Out.print('blue', self.time.strftime('%x %X'))
        Out.print('green', self.title)
        print()
        try:
            text = TheParser.unhtml(self.description)
        except SyntaxError as err:
            text = str(err)
        text = text.strip()
        print(wrap_func(text))

    def get_plain_description(self):
        """Returns description without tags."""
        return REMOVE_TAGS_REGEXP.sub('', self.description)


class FeedParser:
    """Parses Arch feed and returns array of `FeedEntry`."""
    @staticmethod
    def _get_text(nodelist):
        buffer = []
        for node in nodelist:
            if node.nodeType == node.TEXT_NODE:
                buffer.append(node.data)
        return ''.join(buffer)

    @staticmethod
    def _get(element, sub_el_name):
        sub_el = element.getElementsByTagName(sub_el_name)[0]
        sub_el_text = FeedParser._get_text(sub_el.childNodes)
        return sub_el_text

    @staticmethod
    def _convert_time(date_rfc2822):
        date_tuple = parsedate_tz(date_rfc2822)
        timestamp = mktime_tz(date_tuple)
        obj = datetime.fromtimestamp(timestamp, timezone.utc)
        return obj

    @staticmethod
    def parse_feed(body):
        """Parse feed and returns list of feed entries."""
        xmldoc = minidom.parse(body)
        item_list = xmldoc.getElementsByTagName('item')
        items = []

        for item in item_list:
            title = FeedParser._get(item, 'title')
            link = FeedParser._get(item, 'link')
            pub_date = FeedParser._get(item, 'pubDate')
            description = FeedParser._get(item, 'description')
            time_formatted = FeedParser._convert_time(pub_date)
            items.append(FeedEntry(time_formatted, title, link, description))

        return items


# ************************************************************
#  Filters
# ************************************************************

def since_filter(user_input, items):
    """Filtering according time."""
    if isinstance(user_input, datetime):
        sfilter = user_input
    elif '-' in user_input:
        # It should be date in format: YYYY-mm-dd
        sfilter = datetime.strptime(user_input, '%Y-%m-%d')
        # Set correct timezone!
        sfilter = sfilter.replace(tzinfo=timezone.utc)
    else:
        num_days = int(user_input)
        # Get date that is `num_days` before today and time is such as
        # all times the day `num_days`-before today will be later.
        sfilter = (
            datetime.combine(
                # TODO: Somewhat get also date in UTC?
                datetime.today().date() - timedelta(days=num_days),
                datetime.min.time(), tzinfo=timezone.utc))
    return filter(lambda item: sfilter < item.time, items)

def grep_filter(user_input, items):
    """Filtering according text."""
    gfilter = user_input.lower()

    def test(item):
        """Checks for `gfilter` in title and description."""
        return (
            gfilter in item.title.lower() or
            gfilter in item.get_plain_description().lower())

    return filter(test, items)

def order_filter(order, items):
    """Filter filter according order of item."""
    if order > 0:
        items = items[0:order]
    return items


# ************************************************************
#  Unread
# ************************************************************

# TODO: Pass date which would be exact time when items where displayed?
def update_data_file():
    """Stores current date into data file."""
    makedirs(path.dirname(DATA_FILE_PATH), exist_ok=True)

    now = datetime.now(timezone.utc)
    now_formatted = now.strftime(DATA_FILE_FORMAT)

    with open(DATA_FILE_PATH, 'w') as f:
        content = (
            '# This file stores data for "archnews" utility.\n' +
            now_formatted + '\n')
        f.write(content)

def read_data_file():
    """Reads date from data file, `None` is returned if an error occurs."""
    try:
        with open(DATA_FILE_PATH, 'r') as f:
            content = f.read()
            lines = content.split('\n')
    except:
        return None

    def find_line(line):
        """Strips non-commented lines that has no content."""
        linestrip = line.strip()
        return len(linestrip) > 0 and linestrip[0] != '#'

    datestr = next(filter(find_line, lines), None)

    if datestr:
        return datetime.strptime(datestr, DATA_FILE_FORMAT)
    else:
        return None


# ************************************************************
#  main
# ************************************************************

def process_cmd_arguments():
    """Function for processing command line arguments."""
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description='Utility for displaying Arch news feed in console.',
        epilog='''Date and time is converted into local time!

Filters are executed in following order: `-u`, `-s`, `-g` and `-n` (`-n` is last)
and can be combined.

When -u parameter is used, last time of check is stored inside file {}.
'''.format(DATA_FILE_REL_PATH))

    parser.add_argument(
        '-w', '--wrap', help='wrap length, zero for no wrap, default: ' + str(WRAP_SIZE),
        type=int, default=WRAP_SIZE, dest='wrap_size')

    parser.add_argument(
        '-c', '--color', help='do not print in color, default is colorized output',
        default=COLORIZE_OUTPUT, dest='colorize_output', action='store_false')

    parser.add_argument(
        '-i', '--stdin', help='read feed from stdin, do not fetch data from the Internet',
        default=False, dest='stdin', action='store_true')

    parser.add_argument(
        '-r', '--reversed', help='print newest entries first, by default newest entries are last',
        default=ORDER, dest='order', action='store_false')

    parser.add_argument(
        '-u', '--unread', help='''display only previously unread entries''',
        default=False, dest='unread', action='store_true')

    parser.add_argument(
        '-s', '--since', help='''show only entries newer than given date, it can be set as:
integer: entries released before given number of days,
YYYY-mm-dd format: entries released before given date
(In both cases time is not considered, only date!)''',
        dest='since')

    parser.add_argument(
        '-g', '--grep', help='''show only entries that has given string in title or description''',
        dest='grep')

    parser.add_argument(
        '-n', '--num-entries',
        help='''how many entries to show, zero for all, defaults:
if no other filter is set: ''' + str(NUM_ENTRIES) + '''
otherwise zero''',
        type=int, default=-1, dest='num_entries')

    args = parser.parse_args()

    # Set default for `num_entries`.
    if args.num_entries == -1:
        if args.since or args.grep or args.unread:
            args.num_entries = 0
        else:
            args.num_entries = NUM_ENTRIES

    return args

def yes_no_prompt(text):
    """Displays prompt with given `text`. Answer "n" is selected when user enters empty string."""
    run = True
    while run:
        print(text, end='')
        answer = input()
        if answer == '':
            answer = 'n'
        run = (answer not in 'ynYN')
        if run:
            print('Bad input.')
    return answer.lower()

def main(args):
    """Here the interesting part of the script starts."""

    if args.stdin:
        items = FeedParser.parse_feed(sys.stdin)
    else:
        try:
            http_request = request.urlopen(FEED_URL)
        except request.URLError:
            print('Error when trying to fetch Arch Feed News :-(')
            return 1
        items = FeedParser.parse_feed(http_request)

    # Set wrap according parameters.
    Wrap.set(args.wrap_size)

    # Set color output.
    Out.set(args.colorize_output)

    # Set default locale ('' is for the system locale, otherwise
    # e.g. 'cs_CZ.UTF-8' can be used).
    locale.setlocale(locale.LC_ALL, '')

    # First filter: unread.
    if args.unread:
        unread_date = read_data_file()
        if unread_date:
            items = list(since_filter(unread_date, items))

    # Pipe of filters:
    if args.since:
        try:
            items = list(since_filter(args.since, items))
        except:
            print('Bad filter: ' + args.since, file=sys.stderr)
            exit(1)
    if args.grep:
        items = list(grep_filter(args.grep, items))
    items = order_filter(args.num_entries, items)

    # Set correct order.
    if args.order:
        # Function `reversed` cannot be used, it returns iterator
        # that cannot be indexed.
        items = items[::-1]

    # Print results.
    if items:
        for item in items:
            item.print(Wrap.wrap)
            if item == items[-1]:
                print()
            else:
                print('\n\n')
    else:
        print('No news to display.')

    if args.unread and items:
        mark_as_read = yes_no_prompt('Mark messages as read? [y/N]: ')
        if mark_as_read:
            try:
                update_data_file()
            except:
                print('Failed to update ' + DATA_FILE_PATH + '!', file=sys.stderr)
                exit(1)

    return 0


# Run the program.
exit(main(process_cmd_arguments()))


# EOF
